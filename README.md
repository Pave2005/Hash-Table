# Хэш-таблица
## Описание проекта.
В данном проекте проводилось два этапа работы:
- Сравнение семи различных хэш-функций по равномерности распределения элементов в хэш-таблице.
- Профилирование программы и оптимизация функций, которые занимают наибольшую часть времени выполнения программы, в частности функции поиска элемента в хеш-таблице.

## Реализация Хэш-таблицы
В данной реализации хэш-таблица представляет из себя массив структур с индексами, соответствующими хэш-значению* подмножества. Структура состоит из размера подмножества таблицы и указатель на список с элементами таблицы.

Для таблицы определена хэш-функция, которая сопоставляет каждому элементу натуральное число, которое является номером подмножества таблицы.

__* Результат хеш-функции берется по модулю размера таблицы.__

## Фактор загрузки
Фактор загрузки это отношение количества элементов к размеру хеш-таблицы, то есть количество элементов в одном подмножестве таблицы при их равномерном распределении.

В данном проекте для анализа взято произведение "Мастер и Маргарита" (в английском переводе), состоящее из 10962 слов. При обработке текста были "выброшены" все знаки препинания. В исследовании функций был взят взят размер хэш-талицы (2000), так фактор загрузки составлял примерно 5.5, за счет чего лучше видна неравномерность распределения элементов.

## Коллизии в хэш-таблице
В зависимости о хэш-функции, хэш-таблица имеет коллизии*, которые напрямую влияют на поиск элемента в таблице.

[Наглядная схема, иллюстрирующая коллизии](https://www.geeksforgeeks.org/java-program-to-implement-hash-tables-chaining-with-doubly-linked-lists/)
![](pictures/collision.png)

__* Коллизия - совпадений значений hash двух или более объектов.__

## Исследование хэш-функций
Заселенность хэш-таблицы будет показана с помощью гистограмм. По горизонтали указан номер подмножества таблицы. По вертикали количество элементов в соответствующем подмножестве.

Критерием сравнения функций будет дисперсия, которая показывает на сколько равномерно распределены элементы в таблице. Поэтому чем меньше ее значение, тем качественнее хэш-функция.


### Хэш-функции
Я тестировал следующие хэш-функции:
- **HashRetZero ()**
возвращает 0.
- **HashFirstAscii ()**
возвращает ASCII-код первого символа слова.
- **HashWordLen ()**
возвращает длину слова.
- **HashAsciiSum ()**
возвращает сумму всех ASCII-кодов слова.
- **HashOriginal ()**
возвращает сумму всех ASCII-кодов слова, деленную на длину слова.
- **HashRorAscii ()**
- **MurmurHash ()**

### 1. HashRetZero

![](pictures/ret_0.jpg)

В данном случае все элементы таблицы размещены в первом подмножестве таблицы.

Очевидно, что эта хэш-функция обладает низким качеством, так как поиск в таблице превращается в стандартный линейный поиск в одномерном массиве.

### 2. HashFirstAscii

![](pictures/first_ascii.jpg)

Пик коллизий приходится на начало таблицы, так как ASCII-коды символов, которые хэшируют элемент, ограничены значением 255.

### 3. HashWordLen

![](pictures/word_len.jpg)

Мы получили такой результат, так как, длина элемента, в большинстве случаев не превосходит даже 50 элементов, при этом размер таблицы 2000, за счет чего пик коллизий приходится на начало таблицы.

### 4. HashAsciiSum

Данная функция будет исследована при стандартном размере хеш-таблицы и при размере 256. Для второго из них коэффициент загрузки составляет приблизительно 43.

#### Размер 256:
![](pictures/ascii_sum_256.jpg)

На первый взгляд хэш-функция показывает достаточно хороший результат распределения, однако, это характерно только при сравнительно небольших размерах таблицы.

#### Размер 2000:
![](pictures/ascii_sum.jpg)

Как видно здесь уже возникает проблема с коллизиями, все из-за того, что у суммы ASCII-кодов ограничена некоторой константой. Так первый вариант показывает неплохую заселенность, но при больших размерах таблицы появляется пик коллизий и распределение перестает быть равномерным.

### 5. HashOriginal

![](pictures/original.jpg)

Пик приходится на начало таблицы, это обусловливается тем, что в данной функции используется сумма ASCII-кодов и длина, обе этих величины ограничены.

### 6. HashRorAscii

![](pictures/ror.jpg)

Данная функция так же как и представленные выше имеет пики, при этом они распределены по всему размеру таблицы, что говорит о достаточно неплохом хэшировании, но нельзя сказать, что таблица с данной хэш-функцией будет наилучшей для поиска.

### 7. MurmurHash

![](pictures/murmur.jpg)

MurmurHash - достаточно известная хэш-функция. В данном случае распределение равномерное и не имеет пиков.

Об алгоритме этой хэш-функции можно прочитать здесь [MurmurHash2](https://ru.wikipedia.org/wiki/MurmurHash2)


Дальше эта функция будет использоваться по умолчанию.


### Анализ полученных результатов
| Хэш-функция | Дисперсия |
|:-----------:|:---------:|
|MurmurHash|5.79|
|HashRorAscii|23.68|
|HashAsciiSum (256)| 54|
|HashAsciiSum (2000)|81|
|HashFirstAscii| 2799     |
|HashOriginal| 5503|
|HashWordLen| 7263|
| HashRetZero |   60083   |


Среди исследованных функций лучшей является MurmurHash. Этот результат является ожидаемым, поскольку данный алгоритм используется на практике. Во второй части данного проекта эта функция будет использоваться по умолчанию.

## Оптимизация программы






